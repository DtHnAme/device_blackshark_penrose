From 5cc95b181dbbabab5222ffa1c2d96109a5e49a52 Mon Sep 17 00:00:00 2001
From: DtHnAme <1904685725@qq.com>
Date: Tue, 14 Feb 2023 09:35:00 +0800
Subject: [PATCH 1/2] base: Add SmartSwitchChanged api

Change-Id: I11838f46d2e17221ce63e192a9ee762e65be6133
---
 config/boot-image-profile.txt                 |   3 +
 config/preloaded-classes                      |   3 +
 .../android/hardware/input/IInputManager.aidl |   3 +
 .../input/ISmartSwitchChangedListener.aidl    |  22 ++++
 .../android/hardware/input/InputManager.java  | 103 +++++++++++++++++
 .../server/input/InputManagerService.java     | 105 ++++++++++++++++++
 6 files changed, 239 insertions(+)
 create mode 100644 core/java/android/hardware/input/ISmartSwitchChangedListener.aidl

diff --git a/config/boot-image-profile.txt b/config/boot-image-profile.txt
index 3449010e..b7410d6b 100644
--- a/config/boot-image-profile.txt
+++ b/config/boot-image-profile.txt
@@ -42601,6 +42601,9 @@ Landroid/hardware/input/IInputManager;
 Landroid/hardware/input/ITabletModeChangedListener$Stub$Proxy;
 Landroid/hardware/input/ITabletModeChangedListener$Stub;
 Landroid/hardware/input/ITabletModeChangedListener;
+Landroid/hardware/input/ISmartSwitchChangedListener$Stub$Proxy;
+Landroid/hardware/input/ISmartSwitchChangedListener$Stub;
+Landroid/hardware/input/ISmartSwitchChangedListener;
 Landroid/hardware/input/InputDeviceIdentifier$1;
 Landroid/hardware/input/InputDeviceIdentifier;
 Landroid/hardware/input/InputManager$InputDeviceListener;
diff --git a/config/preloaded-classes b/config/preloaded-classes
index 0bac2d1a..196b7a1d 100644
--- a/config/preloaded-classes
+++ b/config/preloaded-classes
@@ -2473,6 +2473,9 @@ android.hardware.input.IInputManager
 android.hardware.input.ITabletModeChangedListener$Stub$Proxy
 android.hardware.input.ITabletModeChangedListener$Stub
 android.hardware.input.ITabletModeChangedListener
+android.hardware.input.ISmartSwitchChangedListener$Stub$Proxy
+android.hardware.input.ISmartSwitchChangedListener$Stub
+android.hardware.input.ISmartSwitchChangedListener
 android.hardware.input.InputDeviceIdentifier$1
 android.hardware.input.InputDeviceIdentifier
 android.hardware.input.InputManager$InputDeviceListener
diff --git a/core/java/android/hardware/input/IInputManager.aidl b/core/java/android/hardware/input/IInputManager.aidl
index fb44b0b6..2e2d8ec4 100644
--- a/core/java/android/hardware/input/IInputManager.aidl
+++ b/core/java/android/hardware/input/IInputManager.aidl
@@ -21,6 +21,7 @@ import android.hardware.input.InputDeviceIdentifier;
 import android.hardware.input.KeyboardLayout;
 import android.hardware.input.IInputDevicesChangedListener;
 import android.hardware.input.ITabletModeChangedListener;
+import android.hardware.input.ISmartSwitchChangedListener;
 import android.hardware.input.TouchCalibration;
 import android.os.IBinder;
 import android.view.InputDevice;
@@ -79,6 +80,8 @@ interface IInputManager {
     // Registers a tablet mode change listener
     void registerTabletModeChangedListener(ITabletModeChangedListener listener);
 
+    void registerSmartSwitchChangedListener(ISmartSwitchChangedListener listener);
+
     // Queries whether the device's microphone is muted by switch
     int isMicMuted();
 
diff --git a/core/java/android/hardware/input/ISmartSwitchChangedListener.aidl b/core/java/android/hardware/input/ISmartSwitchChangedListener.aidl
new file mode 100644
index 00000000..cea122dd
--- /dev/null
+++ b/core/java/android/hardware/input/ISmartSwitchChangedListener.aidl
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.hardware.input;
+
+/** @hide */
+interface ISmartSwitchChangedListener {
+    oneway void onSmartSwitchChanged(long whenNanos, boolean smartSwitchState);
+}
diff --git a/core/java/android/hardware/input/InputManager.java b/core/java/android/hardware/input/InputManager.java
index 72217a11..1a695c8e 100644
--- a/core/java/android/hardware/input/InputManager.java
+++ b/core/java/android/hardware/input/InputManager.java
@@ -81,6 +81,10 @@ public final class InputManager {
     private final ArrayList<InputDeviceListenerDelegate> mInputDeviceListeners =
             new ArrayList<InputDeviceListenerDelegate>();
 
+    private final Object mSmartSwitchLock = new Object();
+    private SmartSwitchChangedListener mSmartSwitchChangedListener;
+    private List<OnSmartSwitchChangedListenerDelegate> mOnSmartSwitchChangedListeners;
+
     // Guarded by mTabletModeLock
     private final Object mTabletModeLock = new Object();
     private TabletModeChangedListener mTabletModeChangedListener;
@@ -442,6 +446,57 @@ public final class InputManager {
         return -1;
     }
 
+    /** @hide */
+    public void registerOnSmartSwitchChangedListener(OnSmartSwitchChangedListener listener, Handler handler) {
+        if (listener == null) {
+            throw new IllegalArgumentException("listener must not be null");
+        }
+
+        synchronized (mSmartSwitchLock) {
+            if (mOnSmartSwitchChangedListeners == null) {
+                initializeSmartSwitchListenerLocked();
+            }
+            int idx = findOnSmartSwitchChangedListenerLocked(listener);
+            if (idx < 0) {
+                mOnSmartSwitchChangedListeners.add(new OnSmartSwitchChangedListenerDelegate(listener, handler));
+            }
+        }
+    }
+
+    /** @hide */
+    public void unregisterOnSmartSwitchChangedListener(OnSmartSwitchChangedListener listener) {
+        if (listener == null) {
+            throw new IllegalArgumentException("listener must not be null");
+        }
+        synchronized (mSmartSwitchLock) {
+            int idx = findOnSmartSwitchChangedListenerLocked(listener);
+            if (idx >= 0) {
+                mOnSmartSwitchChangedListeners.remove(idx).removeCallbacksAndMessages(null);
+            }
+        }
+    }
+
+    private void initializeSmartSwitchListenerLocked() {
+        final SmartSwitchChangedListener listener = new SmartSwitchChangedListener();
+        try {
+            mIm.registerSmartSwitchChangedListener(listener);
+        } catch (RemoteException ex) {
+            throw ex.rethrowFromSystemServer();
+        }
+        mSmartSwitchChangedListener = listener;
+        mOnSmartSwitchChangedListeners = new ArrayList();
+    }
+
+    private int findOnSmartSwitchChangedListenerLocked(OnSmartSwitchChangedListener listener) {
+        int N = mOnSmartSwitchChangedListeners.size();
+        for (int i = 0; i < N; i++) {
+            if (mOnSmartSwitchChangedListeners.get(i).mListener == listener) {
+                return i;
+            }
+        }
+        return -1;
+    }
+
     /**
      * Queries whether the device is in tablet mode.
      *
@@ -1111,6 +1166,15 @@ public final class InputManager {
     }
 
 
+    private void onSmartSwitchChanged(long whenNanos, boolean smartSwitchState) {
+        synchronized (mSmartSwitchLock) {
+            int N = mOnSmartSwitchChangedListeners.size();
+            for (int i = 0; i < N; i++) {
+                mOnSmartSwitchChangedListeners.get(i).sendSmartSwitchChanged(whenNanos, smartSwitchState);
+            }
+        }
+    }
+
     private void onTabletModeChanged(long whenNanos, boolean inTabletMode) {
         if (DEBUG) {
             Log.d(TAG, "Received tablet mode changed: "
@@ -1195,6 +1259,45 @@ public final class InputManager {
         }
     }
 
+    /** @hide */
+    public interface OnSmartSwitchChangedListener {
+        void onSmartSwitchChanged(long whenNanos, boolean smartSwitchState);
+    }
+
+    private final class SmartSwitchChangedListener extends ISmartSwitchChangedListener.Stub {
+        @Override
+        public void onSmartSwitchChanged(long whenNanos, boolean smartSwitchState) {
+            InputManager.this.onSmartSwitchChanged(whenNanos, smartSwitchState);
+        }
+    }
+
+    private static final class OnSmartSwitchChangedListenerDelegate extends Handler {
+        private static final int MSG_SMART_SWITCH_CHANGED = 0;
+
+        public final OnSmartSwitchChangedListener mListener;
+
+        public OnSmartSwitchChangedListenerDelegate(OnSmartSwitchChangedListener listener, Handler handler) {
+            super(handler != null ? handler.getLooper() : Looper.myLooper());
+            mListener = listener;
+        }
+
+        public void sendSmartSwitchChanged(long whenNanos, boolean smartSwitchState) {
+            SomeArgs args = SomeArgs.obtain();
+            args.argi3 = (int) whenNanos;
+            args.arg1 = (Boolean) smartSwitchState;
+            obtainMessage(MSG_SMART_SWITCH_CHANGED, args).sendToTarget();
+        }
+
+        @Override
+        public void handleMessage(Message msg) {
+            if (msg.what == MSG_SMART_SWITCH_CHANGED) {
+                SomeArgs args = (SomeArgs) msg.obj;
+                boolean smartSwitchState = ((boolean) args.arg1);
+                mListener.onSmartSwitchChanged((long) args.argi3, smartSwitchState);
+            }
+        }
+    }
+
     /** @hide */
     public interface OnTabletModeChangedListener {
         /**
diff --git a/services/core/java/com/android/server/input/InputManagerService.java b/services/core/java/com/android/server/input/InputManagerService.java
index 08b3b777..a37ed47f 100644
--- a/services/core/java/com/android/server/input/InputManagerService.java
+++ b/services/core/java/com/android/server/input/InputManagerService.java
@@ -41,6 +41,7 @@ import android.hardware.display.DisplayManager;
 import android.hardware.display.DisplayViewport;
 import android.hardware.input.IInputDevicesChangedListener;
 import android.hardware.input.IInputManager;
+import android.hardware.input.ISmartSwitchChangedListener;
 import android.hardware.input.ITabletModeChangedListener;
 import android.hardware.input.InputDeviceIdentifier;
 import android.hardware.input.InputManager;
@@ -137,6 +138,7 @@ public class InputManagerService extends IInputManager.Stub
     private static final int MSG_UPDATE_KEYBOARD_LAYOUTS = 4;
     private static final int MSG_RELOAD_DEVICE_ALIASES = 5;
     private static final int MSG_DELIVER_TABLET_MODE_CHANGED = 6;
+    private static final int MSG_DELIVER_SMART_SWITCH_CHANGED = 8;
 
     // Pointer to native input manager service object.
     private final long mPtr;
@@ -149,6 +151,8 @@ public class InputManagerService extends IInputManager.Stub
 
     private final File mDoubleTouchGestureEnableFile;
 
+    private final Object mSmartSwitchLock = new Object();
+
     private WindowManagerCallbacks mWindowManagerCallbacks;
     private WiredAccessoryCallbacks mWiredAccessoryCallbacks;
     private boolean mSystemReady;
@@ -161,6 +165,11 @@ public class InputManagerService extends IInputManager.Stub
     private final List<TabletModeChangedListenerRecord> mTempTabletModeChangedListenersToNotify =
             new ArrayList<>();
 
+    private final SparseArray<SmartSwitchChangedListenerRecord> mSmartSwitchChangedListeners = 
+            new SparseArray<>();
+    private final List<SmartSwitchChangedListenerRecord> mTempSmartSwitchChangedListenersToNotify = 
+            new ArrayList<>();
+
     // Persistent data store.  Must be locked each time during use.
     private final PersistentDataStore mDataStore = new PersistentDataStore();
 
@@ -310,6 +319,11 @@ public class InputManagerService extends IInputManager.Stub
     /** Switch code: Microphone. When set it is off. */
     public static final int SW_MUTE_DEVICE = 0x0e;
 
+    /** Switch code: BlackShark Switch Key bit */
+    public static final int SW_SHARK_KEY = 0x0a;
+    public static final int SW_LIFT_KEY_LEFT = 0x0b;
+    public static final int SW_LIFT_KEY_RIGHT = 0x0c;
+
     public static final int SW_LID_BIT = 1 << SW_LID;
     public static final int SW_TABLET_MODE_BIT = 1 << SW_TABLET_MODE;
     public static final int SW_KEYPAD_SLIDE_BIT = 1 << SW_KEYPAD_SLIDE;
@@ -322,6 +336,10 @@ public class InputManagerService extends IInputManager.Stub
     public static final int SW_CAMERA_LENS_COVER_BIT = 1 << SW_CAMERA_LENS_COVER;
     public static final int SW_MUTE_DEVICE_BIT = 1 << SW_MUTE_DEVICE;
 
+    public static final int SW_SHARK_KEY_BIT = 1 << SW_SHARK_KEY;
+    public static final int SW_LIFT_KEY_LEFT_BIT = 1 << SW_LIFT_KEY_LEFT;
+    public static final int SW_LIFT_KEY_RIGHT_BIT = 1 << SW_LIFT_KEY_RIGHT;
+
     /** Whether to use the dev/input/event or uevent subsystem for the audio jack. */
     final boolean mUseDevInputEventForAudioJack;
 
@@ -1970,6 +1988,23 @@ public class InputManagerService extends IInputManager.Stub
             AudioManager audioManager = mContext.getSystemService(AudioManager.class);
             audioManager.setMicrophoneMuteFromSwitch(micMute);
         }
+
+        if ((switchMask & SW_SHARK_KEY_BIT) != 0 || (switchMask & SW_LIFT_KEY_LEFT_BIT) != 0 || (switchMask & SW_LIFT_KEY_RIGHT_BIT) != 0) {
+            SomeArgs args2 = SomeArgs.obtain();
+            args2.argi1 = (int) (whenNanos & 0xFFFFFFFF);
+            args2.argi2 = (int) (whenNanos >> 32);
+            if ((switchMask & SW_SHARK_KEY_BIT) != 0) {    
+                args2.argi3 = 0;
+                args2.arg1 = Boolean.valueOf((switchValues & SW_SHARK_KEY_BIT) != 0 );
+            } else if (((switchMask & SW_LIFT_KEY_LEFT_BIT) != 0)) {
+                args2.argi3 = 1;
+                args2.arg1 = Boolean.valueOf((switchValues & SW_LIFT_KEY_LEFT_BIT) != 0 ); 
+            } else if (((switchMask & SW_LIFT_KEY_RIGHT_BIT) != 0)) {
+                args2.argi3 = 2;
+                args2.arg1 = Boolean.valueOf((switchValues & SW_LIFT_KEY_RIGHT_BIT) != 0 );
+            }
+            mHandler.obtainMessage(MSG_DELIVER_SMART_SWITCH_CHANGED, args2).sendToTarget();
+        }
     }
 
     // Native callback.
@@ -2334,6 +2369,76 @@ public class InputManagerService extends IInputManager.Stub
                     boolean inTabletMode = (boolean) args.arg1;
                     deliverTabletModeChanged(whenNanos, inTabletMode);
                     break;
+                case MSG_DELIVER_SMART_SWITCH_CHANGED:
+                    SomeArgs arg = (SomeArgs) msg.obj;
+                    deliverSmartSwitchChanged((long) arg.argi3, (boolean) arg.arg1);
+                    break;
+            }
+        }
+    }
+
+    @Override
+    public void registerSmartSwitchChangedListener(ISmartSwitchChangedListener listener) {
+        if (listener == null) {
+            throw new IllegalArgumentException("listener must not be null");
+        }
+        synchronized (mSmartSwitchLock) {
+            final int callingPid = Binder.getCallingPid();
+            if (mSmartSwitchChangedListeners.get(callingPid) != null) {
+                throw new IllegalStateException("The calling process has already registered a SmartSwitchChangedListener.");
+            }
+            SmartSwitchChangedListenerRecord record = 
+                    new SmartSwitchChangedListenerRecord(callingPid, listener);
+            try {
+                listener.asBinder().linkToDeath(record, 0);
+            } catch (RemoteException ex) {
+                throw new RuntimeException(ex);
+            }
+            mSmartSwitchChangedListeners.put(callingPid, record);
+        }
+    }
+
+    private void onSmartSwitchChangedListenerDied(int pid) {
+        synchronized (mSmartSwitchLock) {
+            mSmartSwitchChangedListeners.remove(pid);
+        }
+    }
+
+    private void deliverSmartSwitchChanged(long whenNanos, boolean smartSwitchState) {
+        mTempSmartSwitchChangedListenersToNotify.clear();
+        final int numListeners;
+        synchronized (mSmartSwitchLock) {
+            numListeners = mSmartSwitchChangedListeners.size();
+            for (int i = 0; i < numListeners; i++) {
+                mTempSmartSwitchChangedListenersToNotify.add(
+                        mSmartSwitchChangedListeners.valueAt(i));
+            }
+        }
+        for (int i = 0; i < numListeners; i++) {
+            mTempSmartSwitchChangedListenersToNotify.get(i).notifySmartSwitchChanged(
+                    whenNanos, smartSwitchState);
+        }
+    }
+
+    public final class SmartSwitchChangedListenerRecord implements IBinder.DeathRecipient {
+        private final int mPid;
+        private final ISmartSwitchChangedListener mListener;
+
+        public SmartSwitchChangedListenerRecord(int pid, ISmartSwitchChangedListener listener) {
+            mPid = pid;
+            mListener = listener;
+        }
+
+        public void binderDied() {
+            onSmartSwitchChangedListenerDied(mPid);
+        }
+
+        public void notifySmartSwitchChanged(long whenNanos, boolean smartSwitchState) {
+            try {
+                mListener.onSmartSwitchChanged(whenNanos, smartSwitchState);
+            } catch (RemoteException ex) {
+                Slog.w(TAG, "Failed to notify process " + mPid + " that Smart Switch changed, assuming it died.", ex);
+                binderDied();
             }
         }
     }
-- 
2.34.1

